---
title: "Post processing using erosion and dilation"
author: "Mira Sohn"
output:
    html_document:
        code_folding: hide
        df_print: paged
        # toc: true
        # toc_float: true
        # toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE,
                      message=FALSE,
                      cache.lazy=FALSE)
```

Last run: `r date()`

This workflow is designed to demonstrate image segmentation for Visium analysis 
using the [squidpy (Palla, Spitzer et al., 2022)](https://doi.org/10.1038/s41592-021-01358-2) package.
Refer to the following resources for technical details:

- [Squidpy documentation](https://squidpy.readthedocs.io/en/stable/index.html)
- [Tutorial: Analyze Visium fluorescence data](https://squidpy.readthedocs.io/en/stable/notebooks/tutorials/tutorial_visium_fluo.html)
- [Squidpy GitHub](https://github.com/scverse/squidpy)


```{r rpackages}
library(reticulate)
library(tidyverse)
use_condaenv(params[['conda_env']])
source('config/helpers.R')
```

```{python ppackages}
import numpy as np
import dask.array as da
import matplotlib.pyplot as plt
import squidpy as sq
from dask_image.ndmorph import binary_erosion, binary_dilation
from scipy.ndimage import generate_binary_structure
import xarray as xr
import os
```

```{python config}
# ------------------------------------------------------------------------------
# This chunk configures user-specified variables
# ------------------------------------------------------------------------------

# reticulate::repl_python()

# Convert `params` from R to Python
params = r.params

# Paths to input and output obj
input_obj = params['input_obj']
output_obj = params['output_obj']

# Specify the name of input image layer to be processed
lyr = params['lyr']
thresholding = params['thresholding']

# Specify the size of chunks for height and width
chunksize = int(params['chunksize'])

# Path to output directory
outdir = params['outdir']

# Specify layer to be processed
if thresholding in ["adaptive", "otsu"]:
    lyr_thr = f"image_{thresholding}"
else:
    lyr_thr = "image_sqbn"
```

# Loading input image

```{python loading_input}

# ------------------------------------------------------------------------------
# This chunk imports input image saved as zarr in the previous step
# ------------------------------------------------------------------------------

# Load the Zarr store into an ImageContainer
# Set lazy=True to enable Dask-backed lazy loading, which is memory-efficient for large images.
# You can also specify chunks for Dask if needed.
img = sq.im.ImageContainer.load(input_obj, lazy=True, chunks=chunksize)

print(f"The following file has been loaded: {input_obj}")
print(img)
```

# Erosion {.tabset}

[Erosion](https://en.wikipedia.org/wiki/Erosion_%28morphology%29) removes pixels on object boundaries.
After erosion, remaining lines appear thinner and shapes appear smaller.

We perform erosion to remove small noisy speckles using the 
[`binary_erosion`](https://image.dask.org/en/latest/dask_image.ndmorph.html#dask_image.ndmorph.binary_erosion) 
function from the `dask_image` package.

```{python erosion}

# ------------------------------------------------------------------------------
# This chunk runs erosion using the dask_image package
# ------------------------------------------------------------------------------

# Prep 2D structure for connectivity 2
# NOTE: 
# - rank (int): number of dimensions of the structuring element
# - connectivity (int): from 1 (no diagonal elements are neighbors) to rank 
#                       (all elements are neighbors). Greater connectivity 
#                       results in more pixels removed or added.
structure_2d = generate_binary_structure(rank=2, connectivity=2)

for ch in range(img[lyr].shape[3]):
    # Specify the name of layer for the new processed image
    new_layer = f"erosion_channel_{ch}"
    # Retrieve an array corresponding to the channel
    arr = img[lyr_thr].data[:, :, 0, ch]
    # Run erosion
    arr_er = binary_erosion(arr, structure=structure_2d)
    # Add the processed array to the `ImageContainer` obj
    img.add_img(arr_er, layer=new_layer)

# Prep a list consisting of channel corresponding to processed images
er_lyrs = [c for c in list(img) if 'erosion_channel' in c]

# Create a list storing all dask arrays generated by erosion
er_arrays = [img[l].data for l in er_lyrs]

# Stack the arrays along the last axis
stacked_array = np.dstack(er_arrays)
stacked_array = stacked_array.reshape(img[lyr].shape)

# Add the stacked array to the ImageContainer obj
lyr_processed = f"{lyr}_erosion"
try:
    img[lyr_processed] = stacked_array
except:
    ValueError("Can't add the stacked array to ImageContainer. Wrong dimension!")

# Delete unnecessary layers
for l in er_lyrs:
    del img[l]

print("ImageContainer updated:")
print(img)
```

```{r visualize_erosion, results='asis'}

# ------------------------------------------------------------------------------
# This chunk is used to prepare visualizing processed images
# ------------------------------------------------------------------------------

# Visualize binary images across the channels
for (i in 1:py$img[[py$lyr]][['shape']][[4]]) {
    # Convert into 0-indexing
    i <- i - 1
    cat("## Channel", i, "{.tabset}\n\n")
    # Command to show image
    t_deparsed_1 <- paste0("img.show('", py$lyr_processed, "', channel=", i, ", cmap='gray')")
     t_deparsed_2 <- paste0("plt.savefig('", py$outdir, "/erosion_channel_", i,  ".png', dpi=1000)")
    t_deparsed_3 <- "plt.close()"
    t_deparsed <- c(t_deparsed_1, t_deparsed_2, t_deparsed_3)
    subchunkify(name=paste0("erosion_", i), t_deparsed=t_deparsed)

    save_path <- paste0(py$outdir, "/erosion_channel_", i, ".png")
    link_output(paste0("erosion_channel_", i, ".png"))
}

```

# Dilation {.tabset}

[Dilation](https://en.wikipedia.org/wiki/Dilation_(morphology)) adds pixels to the boundaries 
of objects in an image. After dilation, lines appear thicker, and filled shapes appear larger.

We apply dilation after erosion to recover the area of the original foreground objects using the
[`binary_dilation`](https://image.dask.org/en/latest/dask_image.ndmorph.html#dask_image.ndmorph.binary_dilation)
function from the `dask_image` package.

```{python dilation}

# ------------------------------------------------------------------------------
# This chunk runs erosion using the dask_image package
# ------------------------------------------------------------------------------

for ch in range(img[lyr].shape[3]):
    # Specify the name of layer for the new processed image
    new_layer = f"dilation_channel_{ch}"
    # Retrieve an array corresponding to the channel
    arr = img[lyr_processed].data[:, :, 0, ch]
    # Run erosion
    arr_dil = binary_dilation(arr, structure=structure_2d)
    # Add the processed array to the `ImageContainer` obj
    img.add_img(arr_dil, layer=new_layer)

# Prep a list consisting of channel corresponding to processed images
dil_lyrs = [c for c in list(img) if "dilation_channel" in c]

# Create a list storing all dask arrays generated by erosion
dil_arrays = [img[l].data for l in dil_lyrs]

# Stack the arrays along the last axis
stacked_array = np.dstack(dil_arrays)
stacked_array = stacked_array.reshape(img[lyr].shape)

# Add the stacked array to the ImageContainer obj
lyr_processed = f"{lyr}_dilation"
try:
    img[lyr_processed] = stacked_array
except:
    ValueError("Can't add the stacked array to ImageContainer. Wrong dimension!")

# Delete unnecessary layers
for l in dil_lyrs:
    del img[l]

print("ImageContainer updated:")
print(img)
```

```{r visualize_dilation, results='asis'}

# ------------------------------------------------------------------------------
# This chunk is used to prepare visualizing processed images
# ------------------------------------------------------------------------------

# Visualize binary images across the channels
for (i in 1:py$img[[py$lyr]][['shape']][[4]]) {
    # Convert into 0-indexing
    i <- i - 1
    cat("## Channel", i, "{.tabset}\n\n")
    # Command to show image
    t_deparsed_1 <- paste0("img.show('", py$lyr_processed, "', channel=", i, ", cmap='gray')")
     t_deparsed_2 <- paste0("plt.savefig('", py$outdir, "/dilation_channel_", i,  ".png', dpi=1000)")
    t_deparsed_3 <- "plt.close()"
    t_deparsed <- c(t_deparsed_1, t_deparsed_2, t_deparsed_3)
    subchunkify(name=paste0("dilation_", i), t_deparsed=t_deparsed)

    save_path <- paste0(py$outdir, "/dilation_channel_", i, ".png")
    link_output(paste0("dilation_channel_", i, ".png"))
}

```

```{python clean_layers}

# ------------------------------------------------------------------------------
# This chunk is used to delete unwanted layers
# ------------------------------------------------------------------------------

# Delete unnecessary layers
layers_del = [
    'image_adaptive',
    'image_otsu',
    'image_sqbn',
    'image_erosion',
    'image_smooth']
layers_del = [l for l in layers_del if l != lyr_thr]

print("The following layers are deleted: ",
layers_del)
for l in layers_del:
    del img[l]

```

`ImageContainer` updated:

```{r final_img}
print(py$img)
```

# Saving the `ImageContainer` object

Output images are saved as the following object:

```{python save_zarr}
img.save(output_obj)
print(output_obj)
```


```{r session_info, collapse=FALSE}
sessionInfo()
```
