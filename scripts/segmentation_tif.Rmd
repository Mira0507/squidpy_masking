---
title: "Segmentation using squidpy"
author: "Mira Sohn"
output:
    html_document:
        code_folding: hide
        df_print: paged
        # toc: true
        # toc_float: true
        # toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE,
                      message=FALSE,
                      cache.lazy=FALSE)
```

Last run: `r date()`

This workflow is designed to demonstrate image segmentation for Visium analysis 
using the [squidpy (Palla, Spitzer et al., 2022)](https://doi.org/10.1038/s41592-021-01358-2) package.
Refer to the following resources for technical details:

- [Squidpy documentation](https://squidpy.readthedocs.io/en/stable/index.html)
- [Tutorial: Analyze Visium fluorescence data](https://squidpy.readthedocs.io/en/stable/notebooks/tutorials/tutorial_visium_fluo.html)
- [Squidpy GitHub](https://github.com/scverse/squidpy)

```{r rpackages}
library(reticulate)
library(tidyverse)
use_condaenv('../env')
source('helpers.R')
```

```{python ppackages}
import numpy as np
import matplotlib.pyplot as plt
import squidpy as sq
from tifffile import imread
import napari
import os
```

```{python configs}

# ------------------------------------------------------------------------------
# This chunk is used to specify variables for paths to input files/directories
# and parameter settings
# ------------------------------------------------------------------------------

# reticulate::repl_python()

# Specify input image file
input_image = "image_conversion/converted_169.ome.tif"

# Specify argument setting for printing images
channel_config = {
    'Merged' : {'ch' : None, 'cm' : None},
    'Channel 0' : {'ch' : 0, 'cm' : 'gray'},
    'Channel 1' : {'ch' : 1, 'cm' : 'gray'},
    'Channel 2' : {'ch' : 2, 'cm' : 'gray'},
    'Channel 3' : {'ch' : 3, 'cm' : 'gray'},
    'Channel 4' : {'ch' : 4, 'cm' : 'gray'}
}

# Specify the name of input image layer to be processed
lyr = 'image'

# Specify signal values to be tested for Gaussian smoothing
# Sigma represents the variance for normal distribution
gaussian_sigma = 1

# Specify whether input images will be cropped
crop_images = True

# Specify coordinates to crop images
crop_coord = {'height' : 0.3, 'width' : 0.3, 'size' : 5000, 'scale' : 1}

# Specify the segmentation method
seg_method = "watershed"

# Specify the thresholding method. If `None`, the Otsu method is used.
thr_method = None
```

# Loading input images {.tabset}

We use `tif` image files converted from `vsi`. Refer to the [image_conversion.html](image_conversion.html) 
for detailed processes on converting image formats.

The following image object loaded:

```{python load_image}

# ------------------------------------------------------------------------------
# This chunk is used to load input image files
# ------------------------------------------------------------------------------

# Read image as numpy array
img_array = imread(input_image)

# Initialize ImageContainer
img = sq.im.ImageContainer(img_array, layer=lyr)

print(img)

# Crop input images if specified
if crop_images:
    print("Image cropped. Refer to the following dimension:", crop_coord)
    print(crop_coord)
    img = img.crop_corner(x=crop_coord['width'],
                          y=crop_coord['height'],
                          size=crop_coord['size'],
                          scale=crop_coord['scale'])
```

## All

```{python print_all_images, fig.height=12, fig.width=12}

# ------------------------------------------------------------------------------
# This chunk prints all input images at once
# e.g.
# fig, axes = plt.subplots(nrows=3, ncols=2)
# img.show("image", ax=axes[0, 0])
# _ = axes[0, 0].set_title("Merged")
# img.show("image", channel=0, ax=axes[0, 1], cmap='gray')
# _ = axes[0, 1].set_title("Channel 0")
# img.show("image", channel=1, ax=axes[1, 0], cmap='gray')
# _ = axes[1, 0].set_title("Channel 1")
# img.show("image", channel=2, ax=axes[1, 1], cmap='gray')
# _ = axes[1, 1].set_title("Channel 2")
# img.show("image", channel=1, ax=axes[2, 0], cmap='gray')
# _ = axes[2, 0].set_title("Channel 3")
# img.show("image", channel=2, ax=axes[2, 1], cmap='gray')
# _ = axes[2, 1].set_title("Channel 4")
# ------------------------------------------------------------------------------

# Specify plotting arguments
rows = 3
cols = 2

# Initialize subplots
fig, axes = plt.subplots(nrows=rows, ncols=cols)

img.show("image", channel=None, cmap=None)
_ = axes[0, 0].set_title("Merged")
```

```{python load_napari, eval=FALSE}
img.show("image", ax=axes[0, 0])
_ = axes[0, 0].set_title("Merged")
img.show("image", channel=0, ax=axes[0, 1], cmap='gray')
_ = axes[0, 1].set_title("Channel 0")
img.show("image", channel=1, ax=axes[1, 0], cmap='gray')
_ = axes[1, 0].set_title("Channel 1")
img.show("image", channel=2, ax=axes[1, 1], cmap='gray')
_ = axes[1, 1].set_title("Channel 2")
img.show("image", channel=1, ax=axes[2, 0], cmap='gray')
_ = axes[2, 0].set_title("Channel 3")
img.show("image", channel=2, ax=axes[2, 1], cmap='gray')
_ = axes[2, 1].set_title("Channel 4")

# Prep subplot dimensions
subplot_dims = [axes[i, j] for i in range(rows) for j in range(cols)]
# Print plots
for i in range(len(subplot_dims)):
    # Pull pre-specified variables
    key = list(channel_config.keys())[i]
    subdim = subplot_dims[i]
    ch = channel_config[key]['ch']
    cm = channel_config[key]['cm']
    print(subdim, ch, cm)
    # Print
    img.show(lyr, ax=subdim, channel=ch, cmap=cm)
    # Add corresponding title
    _ = subdim.set_title(key)

# Initialize napari viewer
viewer = napari.Viewer()

# Extract ndarray
arr = img.data[lyr].values
# Reorder dimensions
# NOTE: Ensure to have a compatible dimension with Napari (z, channel, y, z)
d_y, d_x, d_z, d_ch = arr.shape
arr_reshaped = arr.reshape(d_z, d_ch, d_y, d_x)
# Add layers of interest to napari viewer
viewer.add_image(arr_reshaped, name=lyr)
# Explore loaded images
napari.run()
```

```{r session_info, collapse=FALSE}
sessionInfo()
```
