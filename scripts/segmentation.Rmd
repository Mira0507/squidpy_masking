---
title: "Segmentation demo using squidpy"
author: "Mira Sohn"
output:
    html_document:
        code_folding: hide
        df_print: paged
        # toc: true
        # toc_float: true
        # toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE,
                      message=FALSE,
                      cache.lazy=FALSE)
```

Last run: `r date()`

This workflow is designed to demonstrate image segmentation for Visium analysis 
using the [squidpy (Palla, Spitzer et al., 2022)](https://doi.org/10.1038/s41592-021-01358-2) package.
Refer to the following resources for technical details:

- [squidpy documentation](https://squidpy.readthedocs.io/en/stable/index.html)
- [squidpy GitHub](https://github.com/scverse/squidpy)

```{r rpackages}
library(reticulate)
library(tidyverse)
use_condaenv('../env')
```

```{python ppackages}
import numpy as np
import matplotlib.pyplot as plt
import squidpy as sq
import os
```

```{python configs}

# ------------------------------------------------------------------------------
# This chunk is used to specify variables for paths to input files/directories
# and parameter settings
# ------------------------------------------------------------------------------

# reticulate::repl_python()

# Specify argument setting for printing images
channel_config = {
    'Merged' : {'ch' : None, 'cm' : None},
    'Channel 0' : {'ch' : 0, 'cm' : 'gray'},
    'Channel 1' : {'ch' : 1, 'cm' : 'gray'},
    'Channel 2' : {'ch' : 2, 'cm' : 'gray'},
}

# Specify the name of input image layer to be processed
lyr = 'image'

# Specify signal values to be tested for Gaussian smoothing
# Sigma represents the variance for normal distribution
gaussian_sigma = 1

# Specify coordinates to crop images
crop_coord = {'height' : 2500, 'width' : 2500, 'size' : 500, 'scale' : 1}
```

```{python functions}

def serial_images(rows, cols, config_dic, target_layer):

    # Initialize subplots
    fig, axes = plt.subplots(nrows=rows, ncols=cols)

    # Prep subplot dimensions
    subplot_dims = [axes[i, j] for i in range(rows) for j in range(cols)]

    # Print plots
    for i in range(len(subplot_dims)):
        # Pull pre-specified variables
        key = list(config_dic.keys())[i]
        subdim = subplot_dims[i]
        ch = config_dic[key]['ch']
        cm = config_dic[key]['cm']
        # Print
        img.show(target_layer,
            ax=subdim,
            channel=ch,
            cmap=cm
            )
        # Add corresponding title
        _ = subdim.set_title(key)
```

# Loading demo images {.tabset}

We use demo images provided by the `squidpy` package. The image is loaded by calling 
the `squidpy.datasets.visium_fluo_image_crop` function.

The following image object loaded:

```{python load_image}

# ------------------------------------------------------------------------------
# This chunk is used to load input image files
# ------------------------------------------------------------------------------

# Load fluorescence tissue images
img = sq.datasets.visium_fluo_image_crop()

print(img)
```

## All

```{python print_all_images, fig.height=12, fig.width=12}

# ------------------------------------------------------------------------------
# This chunk prints all input images at once
# e.g.
# fig, axes = plt.subplots(nrows=2, ncols=2)
# img.show("image", ax=axes[0, 0])
# _ = axes[0, 0].set_title("Merged")
# img.show("image", channel=0, ax=axes[0, 1], cmap='gray')
# _ = axes[0, 1].set_title("Channel 0")
# img.show("image", channel=1, ax=axes[1, 0], cmap='gray')
# _ = axes[1, 0].set_title("Channel 1")
# img.show("image", channel=2, ax=axes[1, 1], cmap='gray')
# _ = axes[1, 1].set_title("Channel 2")
# ------------------------------------------------------------------------------

# Specify plotting arguments
rows = 2
cols = 2

# Initialize subplots
fig, axes = plt.subplots(nrows=rows, ncols=cols)

# Prep subplot dimensions
subplot_dims = [axes[i, j] for i in range(rows) for j in range(cols)]

# Print plots
for i in range(len(subplot_dims)):
    # Pull pre-specified variables
    key = list(channel_config.keys())[i]
    subdim = subplot_dims[i]
    ch = channel_config[key]['ch']
    cm = channel_config[key]['cm']
    # Print
    img.show(lyr,
        ax=subdim,
        channel=ch,
        cmap=cm
        )
    # Add corresponding title
    _ = subdim.set_title(key)
```

## Individuals {.tabset}

### Merged

```{python individual_images_merged}
img.show(lyr)
```

### Channel 0

```{python individual_images_c0}
img.show(lyr, channel=0, cmap='gray')
```

### Channel 1

```{python individual_images_c1}
img.show(lyr, channel=1, cmap='gray')
```

### Channel 2

```{python individual_images_c2}
img.show(lyr, channel=2, cmap='gray')
```

# Converting to grayscale

This step is performed channel-wise by calling the `squidpy.im.process(..., method="gray")` function 
in squidpy.

```{python to_grayscale}

# --------------------------------------------------------------------------------
# This chunk converts the images to grayscale
# --------------------------------------------------------------------------------

stop()
# reticulate::repl_python()
img.show(lyr, channel=0, cmap='gray')
img.show(lyr, channel=1, cmap='gray')
img.show(lyr, channel=2, cmap='gray')

# Convert to grayscale
sq.im.process(img, layer=lyr, method="gray", chunks='auto')


img.show('image_gray', channel=0, cmap='gray')
img.show('image_gray', channel=1, cmap='gray')
img.show('image_gray', channel=2, cmap='gray')
```

`ImageContainer` updated:

```{r grayscaled_obj}
py$img
```

# Smoothing {.tabset}

Smoothing is required to reduce noises before image masking. The current workflow uses 
[Gaussian smoothing](https://en.wikipedia.org/wiki/Gaussian_blur) by calling 
the `squidpy.im.process(..., method="smooth")`, which implements the `skimage.filters.gaussian` function 
in the `scikit-image` package in python.

```{python smoothing}

# --------------------------------------------------------------------------------
# This chunk runs Gaussian smoothing
# --------------------------------------------------------------------------------

# Run smoothing
lyr_gry = "_".join([lyr, "gray"])
sq.im.process(img, layer=lyr_gry, method="smooth", sigma=gaussian_sigma)
```

`ImageContainer` updated:

```{r smoothened_obj}
py$img
```

Images are compared between the before (left) and the after (right) smoothing, as well as the original 
(upper) and higher (lower) magnification, across the stainings.


```{python function_smooth}

# ------------------------------------------------------------------------------
# This chunk is used to prepare visualizing smoothened images
# ------------------------------------------------------------------------------

# Specify the name of layer containing Gaussian smoothing
lyr_smth = "_".join([lyr_gry, "smooth"])

# Prep cropped images
img_crp = img.crop_corner(x=crop_coord['width'],
                          y=crop_coord['height'],
                          size=crop_coord['size'],
                          scale=crop_coord['scale'])

# Create a function that prints images before and after Gaussian smoothing, with and without zoom-in
def image_original_smooth(image, image_cropped, channel):
    fig, axes = plt.subplots(nrows=2, ncols=2)
    image.show(layer=lyr_gry, ax=axes[0, 0], channel=channel, cmap='gray')
    _ = axes[0, 0].set_title('Original before smoothing')
    image.show(layer=lyr_smth, ax=axes[0, 1], channel=channel, cmap='gray')
    _ = axes[0, 1].set_title('Original after smoothing')
    image_cropped.show(layer=lyr_gry, ax=axes[1, 0], channel=channel, cmap='gray')
    _ = axes[1, 0].set_title('Zoomed before smoothing')
    image_cropped.show(layer=lyr_smth, ax=axes[1, 1], channel=channel, cmap='gray')
    _ = axes[1, 1].set_title('Zoomed after smoothing')

```

## Channel 0

```{python smth_images_c0, fig.width=12, fig.height=12}
image_original_smooth(image=img, image_cropped=img_crp, channel=0)
```

## Channel 1

```{python smth_images_c1, fig.width=12, fig.height=12}

# reticulate::repl_python()

# image_original_smooth(image=img, image_cropped=img_crp, channel=1)

# img.show(layer=lyr_gry, channel=1, cmap='gray')
img.show(layer=lyr_gry, channelwise=True)

fig, axes = plt.subplots(nrows=2, ncols=2)
img.show(layer='image_gray', ax=axes[0, 0], channel=1, cmap='gray')
# _ = axes[0, 0].set_title('Original before smoothing')
# img.show(layer=lyr_smth, ax=axes[0, 1], channel=1, cmap='gray')
# _ = axes[0, 1].set_title('Original after smoothing')
# img_crp.show(layer=lyr_gry, ax=axes[1, 0], channel=1, cmap='gray')
# _ = axes[1, 0].set_title('Zoomed before smoothing')
# img_crp.show(layer=lyr_smth, ax=axes[1, 1], channel=1, cmap='gray')
# _ = axes[1, 1].set_title('Zoomed after smoothing')

# >>> img["image"]
# <xarray.DataArray 'image' (y: 7272, x: 7272, z: 1, channels: 3)> Size: 317MB
# dask.array<transpose, shape=(7272, 7272, 1, 3), dtype=uint16, chunksize=(7272, 7272, 1, 3), chunktype=numpy.ndarray>
# Coordinates:
  # * z        (z) <U38 152B 'V1_Adult_Mouse_Brain_Coronal_Section_2'
# Dimensions without coordinates: y, x, channels
```

## Channel 2

```{python smth_images_c2, fig.width=12, fig.height=12, eval=FALSE}
image_original_smooth(image=img, image_cropped=img_crp, channel=2)
```

# Segmentation

```{r session_info}
sessionInfo()
```
